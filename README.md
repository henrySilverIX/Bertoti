# Engenharia de Software I

We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

## Compreensão do texto

Em projetos de engenhariade software,é necessário se importar com o tempo e saber modificá-lo caso seja a situação do projeto. Além disso, deve-se considerar a escala (dimensão) do projeto e a eficiência para a realização do mesmo.
Em situações em que não se tem precisão no tempo e no crescimento do projeto, e necessário tomar decisões de alto risco, ou seja, decisões de perda e ganho.
As tecnologias possuem vantagens e desvantagens e, cabe ao engenheiro de software saber escolher e saber bem sobre essas tecnologias. Quando se trata disso, estamos pensando sobre decisões de perca e ganho (higher-stakes).

Embora a programação faça parte do trabalho do engenheiro de software, há muitos outros aspectos do trabalho do engenheiro que precisa ser considerado como a manutenção e a modificação que devem ser dadas a um determinado projeto. Não se trata apenas de criar, mas sim de manter o seu trabalho funcionando ao longo do tempo.

## Exemplos de higher-stakes
Falando um pouco mais sobre os higher-stakes e requisitos não funcionais, podemos pensar no uso de sistemas operacionais como o Windows e o Linux. Enquanto o Windows possui uma usuabilidade melhor sendo mais "amigável" ao usuário, ele não é muito seguro, pois existem muitos ataques a esse SO, o que exige do Windows constante atualizações. O linux por outro lado é melhor para segurança, customização e estabilidade. Entretanto, o Linux pode ser mais complicado para o usuário comum.
Quando se esta desenvolvendo aplicativos e softwares, as linguagens de programação também possuem essa relação de ganho e perda. Enquanto Python é uma linguagem pensada em ser mais fácil, seu processamento é mais lento justamente por ser uma linguagem de alto nível. Entratetanto, o mesmo não acontece e C que é uma linguagem de baixo nível. Nessa linguagem, o processamento é mais rápido mas a implementação é mais complicada e é necessário fazer um programa diferente para cada hardware, o que acaba sendo um trabalho mais custoso.
